<!DOCTYPE html>
<html lang="en">
<head>
  <title>Snake</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">   
  <link href="css/bootstrap.min.css" rel="stylesheet">
  <script src="js/jquery-3.5.1.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
</head>
<body>
<style>
  html{
    --color-bg-1: #BCE8F0;
    --color-bg-2: #9BDCE9;
    --color-border-1: #4F8492;
    --color-border-2: #022B3A;
    --color-item-1: #6DA2B0;
    --color-text-1: #022B3A;
    --color-text-2: #044962;
    --color-text-3: #6DA2B0;
  }
  body{
    box-sizing: border-box;
    background-color: var(--color-bg-2);
  	color: var(--color-text-1);
    font-size: 15px;
  	font-family: Verdana, sans-serif;    
  }
  h1{
    border-bottom: 3px solid var(--color-border-1);
    color: var(--color-text-1);
    font-weight: bold;
    letter-spacing: 10px;
    margin-bottom: 30px;
    padding: 10px;
    text-align: center;
  }
  #description{
    margin-bottom: 40px;
  }
  p{
    line-height: 120%;
    text-align: justify;
  }
  .box-n-btn{
    border: 2px solid var(--color-border-1);
    border-radius: 10px;
    padding: 4px 9px 4px 9px;
  }
  .text-box{
    border: 3px solid var(--color-border-1);
    border-radius: 10px;
    background-color: var(--color-bg-1);
    color: var(--color-text-2);
    font-size: 0.8em;
    font-family: Verdana, sans-serif;
    overflow: auto;
    padding: -10px;
    /*padding: 4px 9px 4px 9px;*/
    resize: none;
    margin-bottom: 40px;
  }
  .text-box:focus{
    border-color: var(--color-border-1);
    box-shadow: 0px 0px 0px 0px #000;
  }
  .text-box::placeholder{
    color: var(--color-text-3);
  }
  .text-box:focus::placeholder{
    color: var(--color-text-3);
  }
  .function-button{
    background-color: var(--color-border-1);
    color: white;
    font-size: 1.2em;
    font-weight: bold;
    height: 40px;
    letter-spacing: 2px;
    margin-top: 10px;
  }
  .function-button:active{
    background-color: var(--color-item-1);
    border: 2px solid var(--color-item-1);
  }
</style>

<div id = "main-content" class = "container">
  <div class = "row">
    <h1 class = "col-sm-12">snake</h1>
    <div id = "description" class = "col-sm-10 col-sm-offset-1">
      <p>A classic snake game. Use the W, S, A, D keys to control the snake. For test purposes you can also press G to make the snake grow or press F to reposition the apple to a new random place. The site is not responsive, feel free to use the zoom funcion of the browser if it is too big or too small.</p>
      <p>Your score is: <span id = "sc">0</span></p>
    </div>
  </div>

  <div class = "row">
    <div class = "col-sm-12">
      <div class = "clearfix"></div>
      <canvas id = "canvas-box" class = "text-box" width = "1120" height = "440"></canvas> <!-- Canvas width and height should be dividable by 20 -->
    </div>

    <div class = "col-sm-12">
      <button type = "button" class = "box-n-btn function-button btn-block col-sm-12" onclick = "snakeGame()">start</button>
    </div>
  </div>
</div>

<script>  
  function snakeGame(){

    // ---------[Declaration of global variables]--------- //

    // Variables for the canvas. The top left corner of the canvas has 0,0 coordinate. The bottom right corner has (cnvrgt; cnvbtm)
    var canvas = document.getElementById("canvas-box");
    var ctx = canvas.getContext("2d");
    var ups = 20; // Upscale for one pixel 
    var cnvrgt = 1120 / ups; // Canvas bottom
    var cnvbtm = 440 / ups; // Canvas right

    // Variables for the timing.
    var onecyc = 5; // Length of one cycle - can be used to adjust speed of game. Min 2
    var t = 0; // Timer for each cycle (0 to onecyc)

    // Variables for the position and direction of the snake
    var dirx = 1, diry = 0; // direction of snake movement
    var prev_dirx = 1, prev_diry = 0; // direction of snake movement in the previous cycle
    var snhx = 5, snhy = 5; // position of the head of the snake
    var snx = [5,4,3,2]; // initial snake position
    var sny = [5,5,5,5]; // initial snake position
    
    // Variables related to apple
    var growth = 0; // Initial value of growth. Set to higher number after an apple is eaten.
    var aplx = 12, aply = 12; // Initial position of the apple
    newApple(); // Instatly repositions the apple to a random position

    // Initial score
    var score = 0;
    document.getElementById('sc').innerHTML = score;




    // ---------[The repeated cycle]--------- //
    var timer = setInterval(mainFn, 10);
    function mainFn(){    
      document.addEventListener('keydown', reactToKey); // Checks if any key was pressed. If yes, it might change the direction of the movement
         
      if (t < onecyc){
        t++;
      } else { // In case of a new cycle (new cycle starts if direction is changed or t reaches onecyc).
        newSnHeadGhost(); // Places a ghost snake head to the position based on the direction.
        check180Turn();  // Prevents 180° turns (which would result in the snake immediate hitting itself)
        checkHitSn();  // Checks if the new position would result in the snake hitting itself. If yes, it ends the game.
        checkHitWall();  // Checks if the new position would result in hitting the wall. If yes, it ends the game.
        checkApple();  // Checks if the new position would result in eating an apple. If yes, it places a new apple and grows the snake
        updateSnPos();  // If nothing is hit, the position of the snake is updated to the new position.
        drawSn();  // Clears the canvas and draws the new position of the snake.
        drawRedSq(aplx, aply);  // Draws the apple after clearing the canvas.
        t = 0; // Reset timer to start new cycle
      }
    };
    // ------[End of the repeated cycle]------ //




    // ---------[Functions to invoke]--------- //    
    function reactToKey(k){
      prev_dirx = dirx; // Stores the last direction before the keystroke.
      prev_diry = diry;

      if (k.code == 'KeyW'){ // move up
        dirx = 0;
        diry = -1;
      }
      if (k.code == 'KeyS'){ // move down
        dirx = 0;
        diry = 1;
      }
      if (k.code == 'KeyA'){ // move left
        dirx = -1;
        diry = 0;
      }
      if (k.code == 'KeyD'){ // move right
        dirx = 1;
        diry = 0;
      }
      if (k.code == 'KeyG'){ // grow snake - for test purposes
        growth = 3;
      }
      if (k.code == 'KeyF'){ // place new apple - for test purposes
        newApple();
      }

      // If snake turns, turn immediately, to assist zig-zag movements
      // If a pressed key does not change direction, it won't step forward immediately to prevent jumping forward.
      if (prev_dirx != dirx && prev_diry != diry){
        t = onecyc;
      }        
    };

    function newSnHeadGhost(){
      snhx = snhx + dirx; 
      snhy = snhy + diry;
    };

    function checkHitSn(){
      let i = 0;
      for (i = 0; i < snx.length; i++){
        if (snhx == snx[i] && snhy == sny[i]){
          console.log("Snake has hit itself");
          gameOver();
        }
      }
    };

    function checkHitWall(){
      if (snhx == -1 || snhx == cnvrgt || snhy == -1 || snhy == cnvbtm){
        console.log("Snake has hit a wall");
        gameOver();
      }      
    };

    function checkApple(){
      if (snhx == aplx && snhy == aply){
        growth = 3;
        score++;
        document.getElementById('sc').innerHTML = score;
        newApple();        
        console.log("Apple eaten");
      }
    };

    function check180Turn(){
      if(snhx == snx[1] && snhy == sny[1]){
        snhx = snhx - 2 * dirx;        
        snhy = snhy - 2 * diry;
        console.log("180° turn prevented");
      } 
    }; 

    function updateSnPos(){
      if (growth > 0){
        snx.unshift(snhx);
        sny.unshift(snhy);
        growth--;
      } else {
        snx.pop();
        sny.pop();
        snx.unshift(snhx);
        sny.unshift(snhy);
      }
    };

    function drawSn(){    
      let i = 0;
      clearBg(cnvrgt, cnvbtm);
      for (i = 0; i < snx.length; i++){
        drawSq(snx[i], sny[i]);
      }    
    };

    function drawSq(a, b){
      let x = a * ups;
      let y = b * ups;
      ctx.fillStyle = "#4F8492";
      ctx.fillRect(x, y, ups, ups);
    };

    function drawRedSq(a, b){
      let x = a * ups;
      let y = b * ups;
      ctx.fillStyle = "#AD343E";
      ctx.fillRect(x, y, ups, ups);
    };


    function newApple(){
      let cond = 0;
      let exitCond = 0;
      let i = 0;

      do{ // Places apple to a new position. In case the apple spawns on the snake, a new position is generated.
        cond = 0;      
        aplx = Math.floor(Math.random() * cnvrgt) + 0;
        aply = Math.floor(Math.random() * cnvbtm) + 0;

        for (i = 0; i < snx.length; i++){
          if (aplx == snx[i] && aply == sny[i]){
            console.log("The apple spawned on the snake. New position generated.");
            cond = 1;
          }
        }

        exitCond++; // Breaks the cycle in case of overflow. It stops the game.
        if (exitCond > 1000){
          clearInterval(timer);
          break;
        }
      }
      while(cond != 0);
    };

    function gameOver(){
      alert("Game Over! Your final score is: " + score);
      clearInterval(timer);     
    };

    function clearBg(w, h){ // Screen should be cleared before every new drawSn(). Input: width and height in coordinates.
      ctx.clearRect(0, 0, w * ups, h * ups); // To regain pixels from the coordinates the coordinates should be multiplied by ups.
    };    
  };
</script>
</body>
</html>

<!-- browser-sync start --server --directory --files "**/*" -->
<!-- https://coolors.co/022b3a-044962-4f8492-6da2b0-218397-9bdce9-bce8f0 -->